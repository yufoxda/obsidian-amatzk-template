---
tags:
  - diary
  - webapp
  - ポートフォリオ
  - graph
---
[[ポートフォリオサイト]]のブログ表示に[[obsidianグラフweb]]のようにして行いたい。
これの試作を行う。
obsidian glaph export plugin を使ってobsidianのグラフ情報をwebで表示する。
- 3d-force-graph
を使って表示する。

```js
// 1. グラフを描画するコンテナを取得
const graphContainer = document.getElementById('graph-container');
console.log('Graph container:', graphContainer);

// 2. .dot ファイルを読み込む
console.log('Fetching DOT file...');
fetch('./testest.dot')
    .then(response => {
        console.log('Response received:', response.ok);
        return response.text();
    })
    .then(dotData => {
        console.log('DOT data loaded:', dotData.substring(0, 100) + '...');
        // 3. .dot データをJSON形式に変換する
        const data = parseDotToJson(dotData);
        console.log('Parsed data:', data);
        renderGraph(data);
    })
    .catch(error => {
        console.error('Error loading DOT file:', error);
    });

// 4. DOT形式の文字列を直接パースして3d-force-graph用のJSONに変換する関数
function parseDotToJson(dotData) {
    console.log('Parsing DOT data...');
    const nodes = [];
    const links = [];
    const nodeIds = new Set();
    const nodeLabels = new Map(); // ノードのラベル情報を保存

    // DOT形式の行を解析
    const lines = dotData.split('\n');
    console.log('Number of lines:', lines.length);
    
    lines.forEach((line, index) => {
        line = line.trim();
        if (line === '') return; // 空行をスキップ
        
        // ノード定義の解析 (例: "node_id" [label="label_text", ...])
        const nodeMatch = line.match(/^"?([^"\s]+)"?\s*\[.*label="([^"]+)".*\]/);
        if (nodeMatch) {
            const nodeId = nodeMatch[1];
            const label = nodeMatch[2];
            console.log(`Found node: ${nodeId} -> ${label}`);
            nodeLabels.set(nodeId, label);
            
            if (!nodeIds.has(nodeId)) {
                nodes.push({ 
                    id: nodeId, 
                    label: label,
                    name: label
                });
                nodeIds.add(nodeId);
            }
        }
        
        // エッジ定義の解析 (例: "source" -> "target";)
        const edgeMatch = line.match(/^"?([^"\s]+)"?\s*->\s*"?([^"\s;]+)"?/);
        if (edgeMatch) {
            const sourceId = edgeMatch[1];
            const targetId = edgeMatch[2];
            console.log(`Found edge: ${sourceId} -> ${targetId}`);
            
            // ソースノードを追加 (まだなければ)
            if (!nodeIds.has(sourceId)) {
                const label = nodeLabels.get(sourceId) || sourceId;
                nodes.push({ 
                    id: sourceId, 
                    label: label,
                    name: label
                });
                nodeIds.add(sourceId);
            }
            
            // ターゲットノードを追加 (まだなければ)
            if (!nodeIds.has(targetId)) {
                const label = nodeLabels.get(targetId) || targetId;
                nodes.push({ 
                    id: targetId, 
                    label: label,
                    name: label
                });
                nodeIds.add(targetId);
            }
            
            // リンクを追加
            links.push({ source: sourceId, target: targetId });
        }
    });

    console.log(`Parsed ${nodes.length} nodes and ${links.length} links`);
    return { nodes, links };
}


// 5. 3Dグラフを描画する関数
function renderGraph(data) {
    console.log('Rendering graph with data:', data);
    
    if (!data.nodes || data.nodes.length === 0) {
        console.error('No nodes to render');
        return;
    }
    
    try {
        const Graph = ForceGraph3D()
            (graphContainer)
            .graphData(data)
            .nodeLabel('name') // ノードにマウスを乗せるとラベルを表示
            .nodeVal(node => 10) // ノードのサイズ
            .nodeColor(node => '#4fc3f7') // ノードの色
            .linkColor(() => '#81c784') // リンクの色
            .linkWidth(2) // リンクの太さ
            .backgroundColor('#000022') // 背景色
            .onNodeClick(node => {
                console.log('Node clicked:', node);
                // クリックしたノードにカメラをフォーカス
                const distance = 200;
                const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
                Graph.cameraPosition(
                    { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }, // new position
                    node, // lookAt ({ x, y, z })
                    2000  // ms transition duration
                );
            });
        
        // 初期カメラ位置を設定
        Graph.cameraPosition({ x: 0, y: 0, z: 400 });
        console.log('Graph rendered successfully');
    } catch (error) {
        console.error('Error rendering graph:', error);
    }
}
```

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>DOT to 3D Graph</title>
    <style>
        body { margin: 0; }
        #graph-container {
            width: 100vw;
            height: 100vh;
            background-color: #000022;
        }
    </style>
</head>
<body>
    <div id="graph-container"></div>

    <script src="https://unpkg.com/three"></script>
    <script src="https://unpkg.com/3d-force-graph"></script>

    <script src="test.js"></script>
</body>
</html>
```
とりあえず表示はできた。

# 次やる
ポートフォリオはnextjsを使う予定（今のところ）なのでnextで作ってみる
```bash
npx create-next-app@latest dot-3d-graph
cd dot-3d-graph
npm install 3d-force-graph three
```

```ts
'use client';
import { useEffect, useRef, useState } from 'react';

const Graph3D = () => {
  const containerRef = useRef();
  const [graphData, setGraphData] = useState({ nodes: [], links: [] });

  // DOTファイルをパースする関数
  const parseDotToJson = (dotData) => {
    const nodes = [];
    const links = [];
    const nodeIds = new Set();
    const nodeLabels = new Map();

    const lines = dotData.split('\n');
    
    lines.forEach(line => {
      line = line.trim();
      if (line === '') return;
      
      // ノード定義の解析
      const nodeMatch = line.match(/^"?([^"\s]+)"?\s*\[.*label="([^"]+)".*\]/);
      if (nodeMatch) {
        const nodeId = nodeMatch[1];
        const label = nodeMatch[2];
        nodeLabels.set(nodeId, label);
        
        if (!nodeIds.has(nodeId)) {
          nodes.push({ 
            id: nodeId, 
            label: label,
            name: label
          });
          nodeIds.add(nodeId);
        }
      }
      
      // エッジ定義の解析
      const edgeMatch = line.match(/^"?([^"\s]+)"?\s*->\s*"?([^"\s;]+)"?/);
      if (edgeMatch) {
        const sourceId = edgeMatch[1];
        const targetId = edgeMatch[2];
        
        if (!nodeIds.has(sourceId)) {
          const label = nodeLabels.get(sourceId) || sourceId;
          nodes.push({ 
            id: sourceId, 
            label: label,
            name: label
          });
          nodeIds.add(sourceId);
        }
        
        if (!nodeIds.has(targetId)) {
          const label = nodeLabels.get(targetId) || targetId;
          nodes.push({ 
            id: targetId, 
            label: label,
            name: label
          });
          nodeIds.add(targetId);
        }
        
        links.push({ source: sourceId, target: targetId });
      }
    });

    return { nodes, links };
  };

  // DOTファイルを読み込む
  useEffect(() => {
    const loadDotFile = async () => {
      try {
        const response = await fetch('/testest.dot');
        const dotData = await response.text();
        const data = parseDotToJson(dotData);
        setGraphData(data);
      } catch (error) {
        console.error('Error loading DOT file:', error);
      }
    };

    loadDotFile();
  }, []);

  // 3Dグラフを初期化
  useEffect(() => {
    if (!containerRef.current || graphData.nodes.length === 0) return;

    // 動的インポートでForceGraph3Dを読み込み（SSR対応）
    import('3d-force-graph').then(({ default: ForceGraph3D }) => {
      const Graph = ForceGraph3D()
        (containerRef.current)
        .graphData(graphData)
        .nodeLabel('name')
        .nodeVal(10)
        .nodeColor('#4fc3f7')
        .linkColor('#81c784')
        .linkWidth(2)
        .backgroundColor('#000022')
        .onNodeClick(node => {
          const distance = 200;
          const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
          Graph.cameraPosition(
            { 
              x: node.x * distRatio, 
              y: node.y * distRatio, 
              z: node.z * distRatio 
            },
            node,
            2000
          );
        });
      
      Graph.cameraPosition({ x: 0, y: 0, z: 400 });
    });
  }, [graphData]);

  return (
    <div 
      ref={containerRef} 
      style={{ 
        width: '100vw', 
        height: '100vh',
        backgroundColor: '#000022'
      }} 
    />
  );
};

export default Graph3D;
```

```ts
'use client';
import dynamic from 'next/dynamic';

const Graph3D = dynamic(() => import('../components/Graph3D'), {
  ssr: false,
  loading: () => <div>Loading 3D Graph...</div>
});

export default function Home() {
  return <Graph3D />;
}
```
